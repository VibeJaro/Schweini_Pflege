<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Schweini: Stable & Fluffy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #ccfbf1;
            overflow: hidden;
            touch-action: none;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }
        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #game-canvas-area {
            position: relative;
            width: 360px;
            height: 500px;
            z-index: 10;
        }
        .pig-shadow {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 260px;
            height: 30px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            filter: blur(8px);
            z-index: 0;
            animation: breatheShadow 3s infinite ease-in-out;
        }
        @keyframes breatheShadow {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.1; }
            50% { transform: translateX(-50%) scale(1.05); opacity: 0.15; }
        }
        #pig-structure-svg, #fur-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #pig-structure-svg {
            z-index: 1;
            transition: filter 0.2s;
        }
        #fur-canvas {
            z-index: 5;
        }
        .toolbar {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            z-index: 100;
        }
        .tool-btn {
            width: 65px;
            height: 65px;
            border-radius: 18px;
            background: #f1f5f9;
            color: #64748b;
            border: 2px solid transparent;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.1s;
        }
        .tool-btn span {
            font-size: 10px;
            margin-top: 2px;
            font-weight: 600;
        }
        .tool-btn.active.sponge { background: #fce7f3; color: #db2777; border-color: #fbcfe8; }
        .tool-btn.active.hose { background: #e0f2fe; color: #0284c7; border-color: #bae6fd; }
        .tool-btn.active.dryer { background: #fef9c3; color: #ca8a04; border-color: #fde047; }
        .tool-btn.active { transform: scale(1.05); }
        .status-pill {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            color: #db2777;
            pointer-events: none;
            transition: all 0.3s;
        }
        .progress-track {
            width: 80px;
            height: 6px;
            background: #f3f4f6;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #db2777;
            width: 0%;
            transition: width 0.3s;
        }
        /* Gamification UI */
        .game-stats {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 12px;
            color: #64748b;
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .star-rating {
            color: #d1d5db;
            font-size: 14px;
        }
        .star-rating .active {
            color: #fbbf24;
        }
        .restart-btn {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #10b981;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .restart-btn:hover {
            background: #059669;
        }
        .high-score {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #9ca3af;
            z-index: 50;
        }
        /* Start Screen */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F7FA 50%, #90EE90 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        #start-screen h1 {
            font-size: 42px;
            color: #ec4899;
            text-shadow: 2px 2px 0 #fff;
            margin-bottom: 10px;
        }
        #start-screen p {
            color: #64748b;
            font-size: 18px;
            margin-bottom: 30px;
        }
        #start-btn {
            background: linear-gradient(135deg, #ec4899, #db2777);
            color: white;
            border: none;
            padding: 18px 45px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(236, 72, 153, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(236, 72, 153, 0.5);
        }
        /* Easter egg */
        .easter-egg-hint {
            position: absolute;
            bottom: 20px;
            font-size: 10px;
            color: #9ca3af;
            opacity: 0.5;
        }
        /* Duck Animation */
        .duck {
            cursor: pointer;
            transition: transform 0.1s;
        }
        .duck:hover {
            transform: scale(1.1);
        }
        @keyframes duckBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        @keyframes duckWaddle {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
    </style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen" style="display: none;">
    <h1>üê∑ Schweini</h1>
    <p>Wasch, sp√ºl & f√∂hn das Schweinchen!</p>
    <button id="start-btn">Los geht's! ‚ú®</button>
    <div class="easter-egg-hint">Tipp: 3x schnell auf die Nase tippen... ü§´</div>
</div>

<!-- Background Environment SVG -->
<svg id="background-svg" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;" viewBox="0 0 360 640" preserveAspectRatio="xMidYMid slice">
    <defs>
        <!-- Warmer Himmelblau-Verlauf -->
        <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#87CEEB;stop-opacity:1" />
            <stop offset="60%" style="stop-color:#B0E0E6;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#E0F7FA;stop-opacity:1" />
        </linearGradient>
        <!-- Gr√ºne Wiese -->
        <linearGradient id="meadowGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#90EE90;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#7CCD7C;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#228B22;stop-opacity:1" />
        </linearGradient>
        <!-- Zaun Holz -->
        <linearGradient id="fenceGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#8B4513;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#A0522D;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#8B4513;stop-opacity:1" />
        </linearGradient>
    </defs>
    
    <!-- Himmel -->
    <rect x="0" y="0" width="360" height="640" fill="url(#skyGradient)"/>
    
    <!-- Wolken -->
    <g opacity="0.9">
        <!-- Wolke 1 -->
        <ellipse cx="60" cy="80" rx="35" ry="20" fill="white"/>
        <ellipse cx="80" cy="70" rx="25" ry="18" fill="white"/>
        <ellipse cx="45" cy="75" rx="20" ry="15" fill="white"/>
        
        <!-- Wolke 2 -->
        <ellipse cx="280" cy="50" rx="30" ry="18" fill="white"/>
        <ellipse cx="300" cy="45" rx="22" ry="15" fill="white"/>
        <ellipse cx="260" cy="48" rx="18" ry="12" fill="white"/>
        
        <!-- Wolke 3 -->
        <ellipse cx="180" cy="30" rx="28" ry="16" fill="white"/>
        <ellipse cx="200" cy="25" rx="20" ry="14" fill="white"/>
        <ellipse cx="160" cy="28" rx="16" ry="11" fill="white"/>
    </g>
    
    <!-- Wiese -->
    <path d="M0,400 Q90,380 180,400 Q270,420 360,400 L360,640 L0,640 Z" fill="url(#meadowGradient)"/>
    <path d="M0,450 Q60,430 120,450 Q180,470 240,450 Q300,430 360,450 L360,640 L0,640 Z" fill="#3CB371" opacity="0.6"/>
    
    <!-- Strohballen -->
    <g transform="translate(280, 440)">
        <circle cx="25" cy="25" r="30" fill="#DAA520"/>
        <circle cx="25" cy="25" r="26" fill="#F4A460" stroke="#B8860B" stroke-width="2" stroke-dasharray="4,4"/>
        <line x1="5" y1="25" x2="45" y2="25" stroke="#B8860B" stroke-width="1" opacity="0.5"/>
        <line x1="15" y1="10" x2="15" y2="40" stroke="#B8860B" stroke-width="1" opacity="0.5"/>
        <line x1="35" y1="10" x2="35" y2="40" stroke="#B8860B" stroke-width="1" opacity="0.5"/>
    </g>
    <g transform="translate(240, 445)">
        <circle cx="20" cy="20" r="25" fill="#DAA520"/>
        <circle cx="20" cy="20" r="21" fill="#F4A460" stroke="#B8860B" stroke-width="2" stroke-dasharray="3,3"/>
    </g>
    
    <!-- Zaun -->
    <g>
        <!-- Zaunpfosten -->
        <rect x="30" y="470" width="12" height="60" fill="url(#fenceGradient)" rx="2"/>
        <rect x="90" y="475" width="12" height="55" fill="url(#fenceGradient)" rx="2"/>
        <rect x="150" y="470" width="12" height="60" fill="url(#fenceGradient)" rx="2"/>
        <rect x="210" y="475" width="12" height="55" fill="url(#fenceGradient)" rx="2"/>
        <rect x="270" y="470" width="12" height="60" fill="url(#fenceGradient)" rx="2"/>
        <rect x="330" y="475" width="12" height="55" fill="url(#fenceGradient)" rx="2"/>
        
        <!-- Zaunlatten horizontal -->
        <rect x="25" y="480" width="320" height="8" fill="#A0522D" rx="2"/>
        <rect x="25" y="510" width="320" height="8" fill="#A0522D" rx="2"/>
        
        <!-- Zaunspitzen -->
        <polygon points="36,470 42,478 30,478" fill="#8B4513"/>
        <polygon points="96,475 102,483 90,483" fill="#8B4513"/>
        <polygon points="156,470 162,478 150,478" fill="#8B4513"/>
        <polygon points="216,475 222,483 210,483" fill="#8B4513"/>
        <polygon points="276,470 282,478 270,478" fill="#8B4513"/>
        <polygon points="336,475 342,483 330,483" fill="#8B4513"/>
    </g>
    
    <!-- Ein paar Blumen -->
    <g>
        <!-- Blume 1 -->
        <line x1="50" y1="540" x2="50" y2="520" stroke="#228B22" stroke-width="3"/>
        <circle cx="50" cy="515" r="6" fill="#FF69B4"/>
        <circle cx="50" cy="515" r="3" fill="#FFD700"/>
        
        <!-- Blume 2 -->
        <line x1="120" y1="550" x2="120" y2="525" stroke="#228B22" stroke-width="3"/>
        <circle cx="120" cy="520" r="6" fill="#FF6347"/>
        <circle cx="120" cy="520" r="3" fill="#FFD700"/>
        
        <!-- Blume 3 -->
        <line x1="320" y1="545" x2="320" y2="520" stroke="#228B22" stroke-width="3"/>
        <circle cx="320" cy="515" r="6" fill="#9370DB"/>
        <circle cx="320" cy="515" r="3" fill="#FFD700"/>
        
        <!-- Blume 4 -->
        <line x1="200" y1="560" x2="200" y2="530" stroke="#228B22" stroke-width="3"/>
        <circle cx="200" cy="525" r="5" fill="#FFA500"/>
        <circle cx="200" cy="525" r="2.5" fill="#FFD700"/>
    </g>
    
    <!-- Sonne -->
    <circle cx="320" cy="60" r="25" fill="#FFD700" opacity="0.9"/>
    <circle cx="320" cy="60" r="30" fill="#FFD700" opacity="0.3"/>
    <circle cx="320" cy="60" r="35" fill="#FFD700" opacity="0.15"/>
    
    <!-- Planschbecken -->
    <g id="pool" transform="translate(20, 420)">
        <ellipse cx="80" cy="40" rx="70" ry="30" fill="#1E90FF" opacity="0.8"/>
        <ellipse cx="80" cy="40" rx="65" ry="26" fill="#00BFFF" opacity="0.9"/>
        <ellipse cx="80" cy="40" rx="60" ry="22" fill="#87CEEB" opacity="0.7"/>
        <!-- Wasserreflexionen -->
        <ellipse cx="60" cy="35" rx="15" ry="5" fill="white" opacity="0.3"/>
        <ellipse cx="95" cy="45" rx="10" ry="3" fill="white" opacity="0.2"/>
    </g>
    
    <!-- Kleine Ente -->
    <g id="duck" class="duck" transform="translate(50, 380)">
        <style>
            #duck { animation: duckBob 2s ease-in-out infinite; }
            #duck-body { animation: duckWaddle 1s ease-in-out infinite; }
        </style>
        <!-- Schwanzfedern -->
        <path id="duck-tail" d="M45,25 Q55,15 50,5 Q52,20 45,25" fill="#FFA500" transform="translate(0, -3)"/>
        <!-- K√∂rper -->
        <ellipse id="duck-body" cx="30" cy="30" rx="20" ry="15" fill="#FFD700"/>
        <!-- Fl√ºgel -->
        <ellipse cx="25" cy="28" rx="10" ry="8" fill="#FFC800"/>
        <!-- Kopf -->
        <circle cx="15" cy="18" r="12" fill="#FFD700"/>
        <!-- Schnabel -->
        <ellipse cx="5" cy="20" rx="6" ry="4" fill="#FF8C00"/>
        <!-- Auge -->
        <circle cx="12" cy="15" r="3" fill="#1f2937"/>
        <circle cx="11" cy="14" r="1" fill="white"/>
        <!-- Kamm -->
        <path d="M12,6 Q15,0 18,6 Q21,0 24,6" fill="#FF4500"/>
        <!-- F√º√üe -->
        <path d="M20,45 L15,52 M20,45 L20,53 M20,45 L25,52" stroke="#FF8C00" stroke-width="2" fill="none"/>
    </g>
</svg>

<div id="app-container">
    <div class="game-stats">
        <span id="game-stars" class="star-rating">
            <span class="star">‚òÖ</span>
            <span class="star">‚òÖ</span>
            <span class="star">‚òÖ</span>
        </span>
        <span id="attempt-count">Versuch: 1</span>
    </div>
    <div class="high-score" id="high-score">Best: -</div>
    <button id="restart-btn" class="restart-btn">Nochmal spielen! üîÑ</button>
    <div class="status-pill" id="status-container">
        <span id="status-text">Einseifen!</span>
        <div class="progress-track">
            <div class="progress-fill" id="progress-bar"></div>
        </div>
    </div>
    <div id="game-canvas-area">
        <div class="pig-shadow"></div>
        <svg id="pig-structure-svg" viewBox="0 0 360 500">
            <defs>
                <linearGradient id="skinGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#fce7f3;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#fbcfe8;stop-opacity:1" />
                </linearGradient>
            </defs>
            <!-- Beine -->
            <g id="g-leg-l" transform-origin="120 340">
                <circle cx="120" cy="360" r="35" fill="url(#skinGradient)"/>
                <!-- H√∂schen Links -->
                <rect x="95" y="330" width="50" height="40" rx="8" fill="#3b82f6"/>
                <rect x="95" y="330" width="50" height="8" rx="4" fill="#2563eb"/>
            </g>
            <g id="g-leg-r" transform-origin="240 340">
                <circle cx="240" cy="360" r="35" fill="url(#skinGradient)"/>
                <!-- H√∂schen Rechts -->
                <rect x="215" y="330" width="50" height="40" rx="8" fill="#3b82f6"/>
                <rect x="215" y="330" width="50" height="8" rx="4" fill="#2563eb"/>
            </g>
            <!-- K√∂rper mit Hemdchen -->
            <g id="g-body" transform-origin="180 300">
                <circle cx="180" cy="260" r="105" fill="url(#skinGradient)"/>
                <ellipse cx="180" cy="270" rx="65" ry="75" fill="#fff1f2" opacity="0.8" />
                <!-- Rotes Hemdchen mit wei√üen Punkten -->
                <ellipse cx="180" cy="280" rx="75" ry="65" fill="#ef4444"/>
                <ellipse cx="180" cy="280" rx="75" ry="65" fill="none" stroke="#dc2626" stroke-width="3"/>
                <!-- Wei√üe Punkte auf dem Hemd -->
                <circle cx="140" cy="260" r="6" fill="white" opacity="0.9"/>
                <circle cx="165" cy="245" r="6" fill="white" opacity="0.9"/>
                <circle cx="195" cy="245" r="6" fill="white" opacity="0.9"/>
                <circle cx="220" cy="260" r="6" fill="white" opacity="0.9"/>
                <circle cx="150" cy="280" r="6" fill="white" opacity="0.9"/>
                <circle cx="180" cy="265" r="6" fill="white" opacity="0.9"/>
                <circle cx="210" cy="280" r="6" fill="white" opacity="0.9"/>
                <circle cx="155" cy="300" r="6" fill="white" opacity="0.9"/>
                <circle cx="180" cy="295" r="6" fill="white" opacity="0.9"/>
                <circle cx="205" cy="300" r="6" fill="white" opacity="0.9"/>
                <circle cx="165" cy="315" r="6" fill="white" opacity="0.9"/>
                <circle cx="195" cy="315" r="6" fill="white" opacity="0.9"/>
                <!-- Hemdchen Saum -->
                <path d="M105,320 Q180,340 255,320" stroke="#dc2626" stroke-width="4" fill="none" stroke-linecap="round"/>
                <g transform="translate(145, 290) scale(0.7) rotate(-10)">
                    <path d="M20,0 Q30,-10 40,0 Q50,10 40,20 Q30,30 20,20 L20,35 L15,35 L15,20 Q5,30 -5,20 Q-15,10 -5,0 Q5,-10 15,0 Z" fill="#15803d"/>
                </g>
            </g>
            <g id="g-arm-l" transform-origin="110 210"><circle cx="90" cy="220" r="30" fill="url(#skinGradient)"/></g>
            <g id="g-arm-r" transform-origin="250 210"><circle cx="270" cy="220" r="30" fill="url(#skinGradient)"/></g>
            <g id="g-head" transform-origin="180 190">
                <g id="g-ear-l" transform-origin="125 95"><ellipse cx="100" cy="80" rx="30" ry="40" transform="rotate(-20 100 80)" fill="url(#skinGradient)"/></g>
                <g id="g-ear-r" transform-origin="235 95"><ellipse cx="260" cy="80" rx="30" ry="40" transform="rotate(20 260 80)" fill="url(#skinGradient)"/></g>
                <circle cx="180" cy="140" r="95" fill="url(#skinGradient)"/>
                <!-- Niedliche pinke Schleife am Kopf -->
                <g id="g-bow" transform="translate(180, 65)">
                    <ellipse cx="-18" cy="0" rx="18" ry="12" fill="#ec4899" transform="rotate(-15)"/>
                    <ellipse cx="18" cy="0" rx="18" ry="12" fill="#ec4899" transform="rotate(15)"/>
                    <circle cx="0" cy="0" r="8" fill="#db2777"/>
                    <circle cx="0" cy="0" r="4" fill="#f472b6"/>
                </g>
                <g transform="translate(0, -20)">
                    <circle cx="145" cy="140" r="5" fill="#1f2937"/>
                    <circle cx="215" cy="140" r="5" fill="#1f2937"/>
                    <circle cx="147" cy="138" r="1.5" fill="white"/>
                    <circle cx="217" cy="138" r="1.5" fill="white"/>
                    <circle cx="130" cy="180" r="8" fill="#f472b6" opacity="0.4" />
                    <circle cx="230" cy="180" r="8" fill="#f472b6" opacity="0.4" />
                </g>
                <g transform="translate(180, 170)">
                    <ellipse cx="0" cy="0" rx="40" ry="30" fill="#fbcfe8" stroke="#f472b6" stroke-width="2"/>
                    <circle cx="-12" cy="-2" r="4" fill="#be185d" opacity="0.6"/>
                    <circle cx="12" cy="-2" r="4" fill="#be185d" opacity="0.6"/>
                </g>
            </g>
        </svg>
        <canvas id="fur-canvas"></canvas>
    </div>

    <div class="toolbar">
        <button class="tool-btn active sponge" id="btn-sponge">
            <i class="fas fa-soap"></i>
            <span>Seife</span>
        </button>
        <button class="tool-btn hose" id="btn-hose">
            <i class="fas fa-shower"></i>
            <span>Sp√ºlen</span>
        </button>
        <button class="tool-btn dryer" id="btn-dryer">
            <i class="fas fa-wind"></i>
            <span>Trocknen</span>
        </button>
    </div>
</div>

<script>
// ========== Audio System ==========
let audioCtx = null;
let audioInitialized = false;

function initAudio() {
    if (!audioInitialized) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioInitialized = true;
    }
    if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

// Enten-Quak-Ger√§usch
function playQuackSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(300, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.2);
}

// Hoher, kurzer Ton f√ºr Seifenblasen
function playBubbleSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800 + Math.random() * 400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1200 + Math.random() * 200, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.15);
}

// Rauschendes Ger√§usch f√ºr Wasser
function playWaterSound() {
    if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.3;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.3;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start(audioCtx.currentTime);
}

// Tieferes Rauschen f√ºr F√∂hn
function playDryerSound() {
    if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.4;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.4;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 800;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start(audioCtx.currentTime);
}

// Fr√∂hlicher Ton f√ºr erfolgreiche Aktionen
function playHappySound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(523, audioCtx.currentTime);
    osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
    osc.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.35);
}

// ========== Game Code ==========
const canvas = document.getElementById('fur-canvas');
const ctx = canvas.getContext('2d');
const gameArea = document.getElementById('game-canvas-area');
const svgEl = document.getElementById('pig-structure-svg');
const btnSponge = document.getElementById('btn-sponge');
const btnHose = document.getElementById('btn-hose');
const btnDryer = document.getElementById('btn-dryer');

const parts = {
    head: { id: 'g-head', cx: 180, cy: 140, r: 90, baseX: 180, baseY: 190, rotation: 0 },
    body: { id: 'g-body', cx: 180, cy: 260, r: 100, baseX: 180, baseY: 300, rotation: 0 },
    armL: { id: 'g-arm-l', cx: 90, cy: 220, r: 28, baseX: 110, baseY: 210, rotation: 0 },
    armR: { id: 'g-arm-r', cx: 270, cy: 220, r: 28, baseX: 250, baseY: 210, rotation: 0 },
    legL: { id: 'g-leg-l', cx: 120, cy: 360, r: 32, baseX: 120, baseY: 340, rotation: 0 },
    legR: { id: 'g-leg-r', cx: 240, cy: 360, r: 32, baseX: 240, baseY: 340, rotation: 0 },
    earL: { id: 'g-ear-l', cx: 100, cy: 80, r: 28, baseX: 125, baseY: 95, rotation: 0 },
    earR: { id: 'g-ear-r', cx: 260, cy: 80, r: 28, baseX: 235, baseY: 95, rotation: 0 },
    bow: { id: 'g-bow', cx: 180, cy: 65, r: 25, baseX: 180, baseY: 65, rotation: 0 }
};

const config = {
    hairCount: 6000,
    hairLengthDry: 6,
    hairLengthWet: 12,
    baseColors: { r: 255, g: 240, b: 245 },
    dirtColors: [
        {r:101,g:67,b:33},
        {r:85,g:107,b:47},
        {r:110,g:100,b:100}
    ]
};

let hairs = [];
let particles = [];
let mouse = { x: -100, y: -100, isDown: false };
let currentTool = 'sponge';
let stats = { dirt: 100, wetness: 0, soap: 0 };
let dirtPatches = [];
let time = 0;

function init() {
    resize();
    createDirtPatches();
    spawnHairs();
    btnSponge.addEventListener('click', () => { initAudio(); updateToolUI('sponge'); });
    btnHose.addEventListener('click', () => { initAudio(); updateToolUI('hose'); });
    btnDryer.addEventListener('click', () => { initAudio(); updateToolUI('dryer'); });
    updateToolUI('sponge');
    
    // Duck click handler
    const duck = document.getElementById('duck');
    if (duck) {
        duck.addEventListener('click', (e) => {
            e.stopPropagation();
            initAudio();
            playQuackSound();
            // Make duck jump/bounce
            duck.style.transition = 'transform 0.1s';
            duck.style.transform = 'translate(50px, 370px) scale(1.2)';
            setTimeout(() => {
                duck.style.transform = 'translate(50px, 380px) scale(1)';
            }, 150);
            // Spawn heart particles
            for(let i=0; i<3; i++) {
                setTimeout(() => {
                    spawnParticle(65 + i*10, 360, 'heart');
                }, i * 100);
            }
        });
    }
    
    loop();
}

function updateToolUI(tool) {
    currentTool = tool;
    btnSponge.classList.remove('active');
    btnHose.classList.remove('active');
    btnDryer.classList.remove('active');
    const statusText = document.getElementById('status-text');
    const statusContainer = document.getElementById('status-container');
    if(tool === 'sponge') {
        btnSponge.classList.add('active');
        statusText.innerText = "Einseifen!";
        statusContainer.style.color = "#db2777";
    } else if (tool === 'hose') {
        btnHose.classList.add('active');
        statusText.innerText = "Absp√ºlen!";
        statusContainer.style.color = "#0284c7";
    } else {
        btnDryer.classList.add('active');
        statusText.innerText = "F√∂hnen!";
        statusContainer.style.color = "#ca8a04";
    }
}

function resize() {
    canvas.width = gameArea.clientWidth;
    canvas.height = gameArea.clientHeight;
}

function createDirtPatches() {
    const count = 7 + Math.random() * 4;
    for(let i=0; i<count; i++) {
        dirtPatches.push({
            x: 100 + Math.random() * 160,
            y: 100 + Math.random() * 250,
            radius: 35 + Math.random() * 50,
            type: Math.floor(Math.random() * config.dirtColors.length),
            intensity: 0.7 + Math.random() * 0.3
        });
    }
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

function isFaceZone(x, y) {
    if (dist(x, y, 145, 120) < 18) return true;
    if (dist(x, y, 215, 120) < 18) return true;
    if (dist(x, y, 180, 150) < 42) return true;
    return false;
}

function spawnHairs() {
    hairs = [];
    let attempts = 0;
    const partKeys = Object.keys(parts);
    while(hairs.length < config.hairCount && attempts < 150000) {
        attempts++;
        const wx = Math.random() * canvas.width;
        const wy = Math.random() * canvas.height;
        if(isFaceZone(wx, wy)) continue;
        let attachedPart = null;
        for(let key of partKeys) {
            const p = parts[key];
            if(dist(wx, wy, p.cx, p.cy) < p.r) {
                attachedPart = key;
                break;
            }
        }
        if (attachedPart) {
            const p = parts[attachedPart];
            const normalAngle = Math.atan2(wy - p.cy, wx - p.cx);
            let dirtLevel = 0;
            let dirtType = 0;
            dirtPatches.forEach(patch => {
                const d = dist(wx, wy, patch.x, patch.y);
                if (d < patch.radius) {
                    const factor = (1 - d/patch.radius) * patch.intensity;
                    if (factor > dirtLevel) {
                        dirtLevel = factor;
                        dirtType = patch.type;
                    }
                }
            });
            if(dirtLevel > 0) dirtLevel += (Math.random() - 0.5) * 0.2;
            dirtLevel = Math.max(0, Math.min(1, dirtLevel));
            const curlNoise = (Math.random() - 0.5) * 2.5;
            hairs.push({
                part: attachedPart,
                lx: wx - p.cx,
                ly: wy - p.cy,
                x: wx,
                y: wy,
                normalAngle: normalAngle,
                currentAngle: normalAngle + curlNoise,
                curlOffset: curlNoise,
                dirt: dirtLevel,
                dirtType: dirtType,
                wet: 0.0,
                soap: 0.0
            });
        }
    }
}

function updateAnimation() {
    time += 0.05;
    parts.head.rotation = Math.sin(time * 0.5) * 5;
    parts.armL.rotation = Math.sin(time * 0.8) * 10;
    parts.armR.rotation = Math.cos(time * 0.7) * 10;
    const twitch = (Math.random() > 0.98) ? 15 : 0;
    const headRot = parts.head.rotation;
    parts.earL.rotation = headRot + Math.sin(time * 1.2) * 5 + twitch;
    parts.earR.rotation = headRot + Math.cos(time * 1.1) * 5 - twitch;
    parts.bow.rotation = headRot * 0.8 + Math.sin(time * 0.6) * 3; // Bow moves with head
    
    // Animate duck (additional subtle movement on top of CSS animation)
    const duck = document.getElementById('duck');
    if (duck) {
        const duckY = 380 + Math.sin(time * 2) * 2;
        const duckX = 50 + Math.sin(time * 0.5) * 3;
        duck.setAttribute('transform', `translate(${duckX}, ${duckY})`);
    }
    const breatheScale = 1 + Math.sin(time * 0.3) * 0.02;
    for(let key in parts) {
        const p = parts[key];
        const el = document.getElementById(p.id);
        if(el) {
            el.style.transform = `rotate(${p.rotation}deg)`;
            if(key === 'body') el.style.transform += `scale(${breatheScale})`;
        }
    }
    hairs.forEach(hair => {
        const p = parts[hair.part];
        const rad = p.rotation * (Math.PI / 180);
        const vecX = (p.cx + hair.lx) - p.baseX;
        const vecY = (p.cy + hair.ly) - p.baseY;
        hair.x = p.baseX + (vecX * Math.cos(rad) - vecY * Math.sin(rad));
        hair.y = p.baseY + (vecX * Math.sin(rad) + vecY * Math.cos(rad));
        hair.dynamicNormal = hair.normalAngle + rad;
    });
}

function handleInput(e) {
    e.preventDefault();
    if(e.type === 'touchend' || e.type === 'mouseup' || e.type === 'mouseleave' || e.type === 'touchcancel') {
        mouse.isDown = false;
        return;
    }
    const rect = canvas.getBoundingClientRect();
    let cx, cy;
    if(e.type.startsWith('touch') && e.touches.length > 0) {
        cx = e.touches[0].clientX;
        cy = e.touches[0].clientY;
    } else {
        cx = e.clientX;
        cy = e.clientY;
    }
    if (cx !== undefined) {
        mouse.x = cx - rect.left;
        mouse.y = cy - rect.top;
        mouse.isDown = true;
    }
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateAnimation();
    let totalDirt = 0;
    let totalWet = 0;
    let totalSoap = 0;
    hairs.forEach(hair => {
        const dx = mouse.x - hair.x;
        const dy = mouse.y - hair.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        const influence = 50;
        if (mouse.isDown && d < influence) {
            if (currentTool === 'sponge') {
                hair.dirt = Math.max(0, hair.dirt - 0.05);
                hair.soap = Math.min(1, hair.soap + 0.08);
                hair.wet = Math.min(1, hair.wet + 0.02);
                if(Math.random() > 0.8) {
                    spawnParticle(hair.x, hair.y, 'bubble');
                    playBubbleSound();
                }
            } else if (currentTool === 'hose') {
                hair.soap = Math.max(0, hair.soap - 0.1);
                hair.wet = Math.min(1, hair.wet + 0.1);
                hair.currentAngle = Math.PI/2;
                if(Math.random() > 0.5) {
                    spawnParticle(hair.x, hair.y, 'water');
                    playWaterSound();
                }
            } else if (currentTool === 'dryer') {
                hair.wet = Math.max(0, hair.wet - 0.05);
                hair.soap = Math.max(0, hair.soap - 0.1);
                if(Math.random() > 0.9 && hair.wet > 0.1) {
                    spawnParticle(hair.x, hair.y, 'steam');
                    spawnParticle(hair.x, hair.y, 'sparkle');
                    playDryerSound();
                }
            }
        }
        // Add heart particles when petting (sponge with low dirt)
        if (mouse.isDown && currentTool === 'sponge' && hair.dirt < 0.3 && Math.random() > 0.97) {
            spawnParticle(hair.x, hair.y, 'heart');
        }
        // Add star particles for good progress
        if (mouse.isDown && stats.dirt < 0.3 && Math.random() > 0.97) {
            spawnParticle(hair.x, hair.y, 'star');
        }
        const heaviness = Math.max(hair.wet, hair.soap);
        const dryAngle = hair.dynamicNormal + hair.curlOffset;
        const wetAngle = Math.PI / 2;
        let targetAngle = dryAngle;
        if (heaviness > 0.1) {
            const weight = Math.min(1, heaviness * 1.5);
            targetAngle = dryAngle * (1-weight) + wetAngle * weight;
        }
        hair.currentAngle += (targetAngle - hair.currentAngle) * 0.2;
        
        const currentLen = config.hairLengthDry * (1 - heaviness) + config.hairLengthWet * heaviness;
        const thickness = (heaviness > 0.5) ? 2 : 3.5;
        let r, g, b;
        const base = config.baseColors;
        const dirtC = config.dirtColors[hair.dirtType];
        r = base.r * (1-hair.dirt) + dirtC.r * hair.dirt;
        g = base.g * (1-hair.dirt) + dirtC.g * hair.dirt;
        b = base.b * (1-hair.dirt) + dirtC.b * hair.dirt;
        if(hair.soap > 0) {
            r = r * (1-hair.soap) + 255 * hair.soap;
            g = g * (1-hair.soap) + 255 * hair.soap;
            b = b * (1-hair.soap) + 255 * hair.soap;
        }
        if(hair.wet > 0) {
            const wetFactor = 0.6 * (1 - hair.soap);
            r *= (1 - hair.wet * wetFactor);
            g *= (1 - hair.wet * wetFactor);
            b *= (1 - hair.wet * wetFactor);
        }
        ctx.beginPath();
        ctx.moveTo(hair.x, hair.y);
        const tipX = hair.x + Math.cos(hair.currentAngle) * currentLen;
        const tipY = hair.y + Math.sin(hair.currentAngle) * currentLen;
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
        ctx.lineWidth = thickness;
        ctx.lineCap = 'round';
        ctx.stroke();
        totalDirt += hair.dirt;
        totalWet += hair.wet;
        totalSoap += hair.soap;
    });
    updateParticles();
    stats.dirt = totalDirt / config.hairCount;
    stats.wetness = totalWet / config.hairCount;
    stats.soap = totalSoap / config.hairCount;
    const brightness = 100 - (stats.wetness * 40);
    svgEl.style.filter = `brightness(${brightness}%)`;
    updateUI();
    requestAnimationFrame(loop);
}

function spawnParticle(x, y, type) {
    let vx, vy;
    if (type === 'heart') {
        vx = (Math.random() - 0.5) * 2;
        vy = -2 - Math.random() * 2;
    } else if (type === 'star') {
        vx = (Math.random() - 0.5) * 1;
        vy = -1.5 - Math.random();
    } else if (type === 'sparkle') {
        vx = (Math.random() - 0.5) * 3;
        vy = (Math.random() - 0.5) * 3;
    } else if (type === 'rainbow') {
        vx = (Math.random() - 0.5) * 2;
        vy = -1 - Math.random();
    } else {
        vx = (Math.random()-0.5) * (type === 'water' ? 3 : 1);
        vy = type === 'water' ? 5 + Math.random()*5 : -1 - Math.random();
    }
    particles.push({
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        life: 1.0,
        type: type,
        size: type === 'bubble' ? 2 + Math.random() * 6 : (type === 'heart' ? 12 : (type === 'star' ? 10 : 3)),
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.2
    });
}

function updateParticles() {
    for(let i=0; i<particles.length; i++) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        if (p.type === 'heart' || p.type === 'star' || p.type === 'rainbow') {
            p.vy += 0.02; // gravity
        }
        p.rotation += p.rotSpeed || 0;
        ctx.beginPath();
        if(p.type === 'bubble') {
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        } else if (p.type === 'water') {
            ctx.fillStyle = `rgba(56, 189, 248, ${p.life})`;
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        } else if (p.type === 'steam') {
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life * 0.4})`;
            ctx.fillRect(p.x, p.y, 2, 6);
        } else if (p.type === 'heart') {
            ctx.fillStyle = `rgba(255, 105, 180, ${p.life})`;
            drawHeart(ctx, p.x, p.y, p.size);
        } else if (p.type === 'star') {
            ctx.fillStyle = `rgba(255, 215, 0, ${p.life})`;
            drawStar(ctx, p.x, p.y, p.size, p.rotation);
        } else if (p.type === 'sparkle') {
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
            drawSparkle(ctx, p.x, p.y, p.size);
        } else if (p.type === 'rainbow') {
            const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
            ctx.fillStyle = colors[Math.floor((1-p.life) * 7)] || colors[0];
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1-p.life+0.5), 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        if(p.life <= 0) {
            particles.splice(i, 1);
            i--;
        }
    }
}

function drawHeart(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    ctx.moveTo(0, -size/2);
    ctx.bezierCurveTo(size/2, -size, size, -size/3, 0, size);
    ctx.bezierCurveTo(-size, -size/3, -size/2, -size, 0, -size/2);
    ctx.fill();
    ctx.restore();
}

function drawStar(ctx, x, y, size, rotation) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawSparkle(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.2, -size * 0.2);
    ctx.lineTo(size, 0);
    ctx.lineTo(size * 0.2, size * 0.2);
    ctx.lineTo(0, size);
    ctx.lineTo(-size * 0.2, size * 0.2);
    ctx.lineTo(-size, 0);
    ctx.lineTo(-size * 0.2, -size * 0.2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function updateUI() {
    const progress = Math.floor((1 - stats.dirt) * 100);
    const statusText = document.getElementById('status-text');
    const progressBar = document.getElementById('progress-bar');
    const starElements = document.querySelectorAll('#game-stars .star');
    
    progressBar.style.width = progress + '%';
    
    // Update star rating based on progress
    let stars = 0;
    if (progress >= 100 && stats.wetness < 0.1) stars = 3;
    else if (progress >= 70) stars = 2;
    else if (progress >= 30) stars = 1;
    
    starElements.forEach((star, i) => {
        star.classList.toggle('active', i < stars);
    });
    
    if (stats.dirt > 0.1) {
    } else if (stats.soap > 0.1) {
        if (currentTool !== 'hose' && Math.random() > 0.95) statusText.innerText = "Schaum absp√ºlen!";
    } else if (stats.wetness > 0.2) {
        if (currentTool !== 'dryer' && Math.random() > 0.95) statusText.innerText = "Trocknen!";
    } else {
        if(Math.random() > 0.99) {
            statusText.innerText = "Kuschelweich!";
            playHappySound();
            // Show restart button and save score
            document.getElementById('restart-btn').style.display = 'block';
            const currentScore = Math.floor((1 - stats.dirt) * 100) - Math.floor(stats.wetness * 20);
            const highScore = localStorage.getItem('schweini-highscore') || 0;
            if (currentScore > highScore) {
                localStorage.setItem('schweini-highscore', currentScore);
                document.getElementById('high-score').textContent = 'Best: ' + currentScore + '!';
            }
            // Spawn rainbow particles when finished!
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    spawnParticle(180 + (Math.random()-0.5)*100, 200 + Math.random()*100, 'rainbow');
                }, i * 100);
            }
        }
    }
}

// Start Screen & Easter Egg
let noseTaps = 0;
let lastNoseTap = 0;

function handleStartScreen() {
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    
    if (startScreen && startBtn) {
        startScreen.style.display = 'flex';
        startBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            initAudio();
        });
    }
    
    // Easter egg: 3x tap on nose
    const noseArea = document.querySelector('[transform="translate(180, 170)"]');
    if (noseArea) {
        noseArea.style.cursor = 'pointer';
        noseArea.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastNoseTap < 500) {
                noseTaps++;
                if (noseTaps >= 3) {
                    // Secret: Free points!
                    noseTaps = 0;
                    alert('üéâ Geheim-Feature: Schweini ist extragl√ºcklich! +50 Punkte!');
                    stats.dirt = Math.max(0, stats.dirt - 0.5);
                }
            } else {
                noseTaps = 1;
            }
            lastNoseTap = now;
        });
    }
}

// Gamification
let attempts = parseInt(localStorage.getItem('schweini-attempts')) || 1;
document.getElementById('attempt-count').textContent = 'Versuch: ' + attempts;
const highScore = localStorage.getItem('schweini-highscore');
if (highScore) document.getElementById('high-score').textContent = 'Best: ' + highScore;

document.getElementById('restart-btn').addEventListener('click', () => {
    localStorage.setItem('schweini-attempts', attempts + 1);
    location.reload();
});

['mousedown', 'mousemove', 'mouseup', 'mouseleave', 'touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(evt => {
    gameArea.addEventListener(evt, handleInput, { passive: false });
});

window.onload = function() {
    handleStartScreen();
    init();
};
</script>
</body>
</html>
